#!/usr/bin/env python3

import argparse
from multiprocessing import Pool, cpu_count
import re
import sys
from termcolor import colored

from PaStA.EquivalenceClass import EquivalenceClass
from PaStA.PatchEvaluation import EvaluationResult, EvaluationType, evaluate_patch_list
from PaStA import config, patch_stack_list
from PaStA.PatchStack import cache_commit_hashes, get_commit_hashes, get_commits_from_file, get_commit


def _evaluate_patch_list_wrapper(args):
    orig, cand, type = args
    return evaluate_patch_list(orig, cand, type)


def analyse_succ():
    # Check patch against next patch version number, patch by patch
    evaluation_list = []
    pred = None
    for patch_stack in patch_stack_list:
        if not pred:
            pred = patch_stack
            continue

        print('Queueing %s <-> %s' % (pred.stack_version, patch_stack.stack_version))
        evaluation_list.append((pred.commit_hashes, patch_stack.commit_hashes, EvaluationType.PatchStack))
        pred = patch_stack

    cache_commit_hashes(patch_stack_list.get_all_commit_hashes())

    print('Starting evaluation.')
    pool = Pool(cpu_count())
    results = pool.map(_evaluate_patch_list_wrapper, evaluation_list)
    pool.close()
    pool.join()
    print('Evaluation completed.')

    evaluation_result = EvaluationResult(EvaluationType.PatchStack)
    evaluation_result.set_universe(patch_stack_list.get_all_commit_hashes())
    for result in results:
        evaluation_result.merge(result)

    return evaluation_result


def analyse_stack(similar_patches):

    # Iterate over similar patch list and get latest commit of patches
    sys.stdout.write('Determining patch stack representative system...')
    sys.stdout.flush()
    # Get the complete representative system
    # The lambda compares two patches of an equivalence class and chooses the one with
    # the later release version
    representatives = similar_patches.get_representative_system(
        lambda x, y: patch_stack_list.is_stack_version_greater(patch_stack_list.get_stack_of_commit(x),
                                                               patch_stack_list.get_stack_of_commit(y)))
    print(colored(' [done]', 'green'))

    # Cache commits
    cache_commit_hashes(representatives)

    result = evaluate_patch_list(representatives,
                                 representatives,
                                 EvaluationType.PatchStack,
                                 parallelize=True,
                                 verbose=True)
    result.set_universe(representatives)

    return result


def analyse_upstream(similar_patches):
    # Load and cache upstream commits
    upstream_candidates = get_commit_hashes(config.upstream_range[0], config.upstream_range[1])
    upstream_candidates -= get_commits_from_file(config.upstream_blacklist)

    sys.stdout.write('Determining patch stack representative system...')
    sys.stdout.flush()
    # Get the complete representative system
    # The lambda compares two patches of an equivalence class and chooses the one with
    # the later release version
    representatives = similar_patches.get_representative_system(
        lambda x, y: patch_stack_list.is_stack_version_greater(patch_stack_list.get_stack_of_commit(x),
                                                               patch_stack_list.get_stack_of_commit(y)))
    print(colored(' [done]', 'green'))

    cache_commit_hashes(upstream_candidates)
    cache_commit_hashes(representatives)

    print('Auto-detecting cherry-picks...')
    cherry_picks = EvaluationResult(EvaluationType.Upstream)
    cherry_picks.set_universe(set())
    cherry_rgxs = [r'.*pick.*',
                   r'.*upstream.*commit.*',
                   r'.*commit.*upstream.*']
    cherry_rgxs = re.compile('(' + ')|('.join(cherry_rgxs) + ')', re.IGNORECASE)
    sha1_regex = re.compile(r'\b([0-9a-fA-F]{5,40})\b')
    for commit_hash in representatives:
        commit = get_commit(commit_hash)
        for line in commit.message:
            if cherry_rgxs.match(line):
                sha_found = sha1_regex.search(line)
                if not sha_found:
                    continue
                upstream_hash = sha_found.group(1)
                if upstream_hash in upstream_candidates:
                    cherry_picks[commit_hash] = [(upstream_hash, 1.0, 1.0, 1.0)]
                else:
                    print('Found cherry-pick: %s <-> %s but upstream is not in upstream candidates list.' %
                          (commit_hash, upstream_hash))
    print('Done. Found %d cherry-picks' % len(cherry_picks))

    print('Starting evaluation.')
    evaluation_result = evaluate_patch_list(representatives, upstream_candidates, EvaluationType.Upstream,
                                            parallelize=True, verbose=True,
                                            cpu_factor=0.5)
    print('Evaluation completed.')

    evaluation_result.merge(cherry_picks)

    # We don't have a universe in this case
    evaluation_result.set_universe(set())

    return evaluation_result


def main():
    parser = argparse.ArgumentParser(description='Analyse stack by stack')
    parser.add_argument('-er', dest='evaluation_result_filename', metavar='filename',
                        default=config.evaluation_result, help='Evaluation result filename')
    parser.add_argument('-sp', dest='sp_filename', metavar='filename',
                        default=config.similar_patches, help='Similar Patches filename')
    parser.add_argument('-mode', dest='mode', default='stack-succ',
                        choices=['init', 'stack-succ', 'stack-rep', 'upstream'],
                        help='Analysation mode: Successive patches on the stack, Compare Representants on the stack,\
                              Upstream Analysis (default: %(default)s)')
    args = parser.parse_args()

    if args.mode == 'init':
        similar_patches = EquivalenceClass.from_file(args.sp_filename, must_exist=False)
        for commit_hash in patch_stack_list.get_all_commit_hashes():
            similar_patches.insert_single(commit_hash)
        similar_patches.to_file(args.sp_filename)
    else:
        # Load similar patches file
        similar_patches = EquivalenceClass.from_file(args.sp_filename, must_exist=True)

        if args.mode == 'stack-succ':
            result = analyse_succ()
        elif args.mode == 'stack-rep':
            result = analyse_stack(similar_patches)
        elif args.mode == 'upstream':
            result = analyse_upstream(similar_patches)

        result.to_file(args.evaluation_result_filename)


if __name__ == '__main__':
    main()

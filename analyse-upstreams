#!/usr/bin/env python3

import argparse
import re
import sys
from termcolor import colored

from PaStA.EquivalenceClass import EquivalenceClass
from PaStA.PatchEvaluation import evaluate_patch_list, EvaluationResult
from PaStA.PatchStack import cache_commit_hashes, get_commit_hashes, get_commit, get_commits_from_file
from PaStA import config, patch_stack_list, repo


def _evaluate_patch_list_wrapper(args):
    orig, cand = args
    return evaluate_patch_list(orig, cand)


def main():
    # Startup
    parser = argparse.ArgumentParser(description='Analyse stack by stack')
    parser.add_argument('-er', dest='evaluation_result_filename', metavar='filename',
                        default=config.evaluation_result, help='Evaluation result filename')
    parser.add_argument('-sp', dest='sp_filename', metavar='filename',
                        default=config.similar_patches, help='Similar Patches filename')
    args = parser.parse_args()

    # Load and cache upstream commits
    upstream_candidates = get_commit_hashes(config.upstream_range[0], config.upstream_range[1])
    upstream_candidates -= get_commits_from_file(config.upstream_blacklist)
    cache_commit_hashes(upstream_candidates, parallelize=True)

    # Load similar patches file
    similar_patches = EquivalenceClass.from_file(args.sp_filename)

    sys.stdout.write('Determining patch stack representative system...')
    sys.stdout.flush()
    # Get the complete representative system
    # The lambda compares two patches of an equivalence class and chooses the one with
    # the later release version
    representatives = similar_patches.get_representative_system(
        lambda x, y: patch_stack_list.is_stack_version_greater(patch_stack_list.get_stack_of_commit(x),
                                                               patch_stack_list.get_stack_of_commit(y)))

    print(colored(' [done]', 'green'))
    cache_commit_hashes(representatives, parallelize=True)

    print('Searching for cherry-picks...')
    cherry_picks = EvaluationResult()
    cherry_picks.set_universe(set())
    cherry_rgxs = [r'.*pick.*',
                   r'.*upstream.*commit.*',
                   r'.*commit.*upstream.*']
    cherry_rgxs = re.compile('(' + ')|('.join(cherry_rgxs) + ')', re.IGNORECASE)
    sha1_regex = re.compile(r'\b([0-9a-fA-F]{5,40})\b')
    for commit_hash in representatives:
        commit = get_commit(commit_hash)
        for line in commit.message:
            if cherry_rgxs.match(line):
                sha_found = sha1_regex.search(line)
                if not sha_found:
                    continue
                upstream_hash = sha_found.group(1)
                if upstream_hash in upstream_candidates:
                    cherry_picks[commit_hash] = [(upstream_hash, 1.0, 1.0, 1.0)]
                else:
                    print('Found cherry-pick: %s <-> %s but upstream is not in upstream candidates list.' %
                          (commit_hash, upstream_hash))
    print('Done. Found %d cherry-picks' % len(cherry_picks))

    print('Starting evaluation.')
    evaluation_result = evaluate_patch_list(representatives, upstream_candidates,
                                            parallelize=True, verbose=True,
                                            cpu_factor=0.5)
    print('Evaluation completed.')

    evaluation_result.merge(cherry_picks)

    # We don't have a universe in this case
    evaluation_result.set_universe(set())
    evaluation_result.to_file(args.evaluation_result_filename)


if __name__ == '__main__':
    main()
